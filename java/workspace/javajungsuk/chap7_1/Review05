1. 상속 
 	생성자와 초기화 블럭은 상속되지 않는다. 멤버만 상속 
	자손 클래스의 멤버 개수는 조상 클래스보다 항상 같거나 많다. 
 	기존 클래스를 재사용하여 새로운 클래스를 작성하는 것 
 	장점 : 재사용성, 코드의 중복 제거 
 * 포함 관계 : 한 클래스의 멤버변수로 다른 타입의 참조변수 선언 (상속: 은 이다 , 포함 : 을 가지고 있다)
    상속은 단 하나의 클래스만 상속 가능(단일 상속 : 다중상속의 경우 메소드 명이 같으면  충돌)




2. 생성자  
   인스턴스가 생성될 때 호출되는 '인스턴스 초기화 메서드 ' 
   객체를 생성할 때 호출되는 메서도 
  * 조건: 생성자 이름은 클래스 이름과 같아야 한다. 생성자는 리턴 값이 없다. 
    모든 클래스는 생성자를 가지고 있다.
    1) 기본 생성자 : 클래스에 생성자를 정의하지 않아도  컴파일러가 자동적으로 추가하여 컴파일하기 때문에 매개변수가 없는 생성일 경우 생략 가능 
    2) 매개변수 있는 생성자 : 생성자에 매개변수를 선언하여 호출시 넘겨받아 인스턴스 초기화 작업에 사용 




3. 제어자 
     클래스, 변수, 메서드 선언부에 함께 사용되어 부가적 의미를 부여함 
     접근제어자 : public, protected, (default), private 
     static : 인스턴스 생성없이 호출가능 
     final : 재정의 불가(오버라이딩 불가), 상수, 조상클래스 사용 불가 (마지막 클래스에서만 가능)
     * 접근 제어자 : 클래스는 public or default => 클래스당 public 은 한개 
     
     
     
4. 다형성 
	  ** 조상타입의 참조변수로 자손타입의 객체를 가리키는 것 
	  장점: 다형적 매개변수(변수의 수 조절), 하나의 배열로 여러 종류의 객체 다루기 가능 
	  참조변수 타입은 반드시 인스턴스 타입과 일치하지 않을 수 있다.
	  참조변수가 조상타입일 때와 자손타입일 때의 차이 : 참조변수로 사용가능한 멤버 수가 달라진다.
	  자손타입의 참조변수가 조상타입 객체 가리키는건  불가능(자손 = 조상 ) ==> why? 자손의 참조변수가 사용할 수 있는 멤버수가 조상의 인스턴스보다 많아서 
	    ==> 만약 자손타입 객체가 조상타입 객체를 사용하고 싶다면  형변환 필수(그러나 기존 인스턴스가 그냥 조상 자체의 인스턴스라면 형변환도 에러 ) 
	   * instance of 로 형변환 가능 여부 확인 가능 (타입을 확인)
 
 관련 그림 및 정리 내 노션 참고 
    https://plausible-bottom-9ea.notion.site/2-de3ca218898e40a4adacbb4909a0dfeb

5. 추상 클래스 
	  구현부가 없는 메소드. 미완성 설계도 
	  자손클래스의 의해서 생성 가능 
	  꼭 필요하지만 자손마다 다르게 구현될 것으로 예상되는 경우 사용 => 다른 클래스 작성에 도움을 준다 . (객체 생성 불가능 )
	  장점 : 관리 용이, 코드 중복 제거 
	  
	  추상클래스 vs 인터페이스 
	  공통점 : 추상메서드 갖고 있음 
	  차이점 : 추상 클래스 : 멤버 변수 + 추상 메서드 
	  		 인터페이스  : 추상 메서드 



6. 인터페이스 
  추상메서드 집합. 기본설계도 
 * 인터페이스의 타입이 매개변수가 갖는 의미는 메서드 호출 시 해당 인터페이스를 구현한 클래스의 인스턴스를 매개변수로 제공해야한다는 것이다. 
 * 리턴타입이 인터페이스라는 것은 메서드가 해당 인터페이스를 구현한 클래스의 인스턴스를 반환한다는 것이다. 




7. 내부 클래스 
  개념 : 내부 클래스는 클래스 내에 선언된 클래스
  장점 : 내부 클래스에서 외부 클래스의 멤버들을 쉽게 접근 가능 
       코드의 복잡성을 줄일 수 있다(캡슐화) 
        
        
