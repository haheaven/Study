  제네릭 

  1. 개념 
   데이터 타입을 일반화하는 것 => 클래스나 메서드에서 사용할 내부 데이터 타입을 컴파일 시에 미리 지정하는 방법 (타입체크)
  
  2. 장점 
    타입 안정성 제공 -> 컴파일 이후 런타임에러는 프로그램이 죽는거지만 컴파일 오류는 미리 확인해서 코드를 수정할 수 있으므로 안정성이 좋다.
    타입체크와 형변환을 생략할 수 있으므로 코드가 간결 
 
  ex)
   * 제네릭 사용x
	ArrayList tvList = new ArrayList();
    tvList.add(new TV());

	TV t = (TV)tvList.get(0);   //  제네릭을 사용하지 않을 경우 형변환 필요		
   
   ------------------------------------------------
  
   * 제네릭 사용 
   ArrayList<Tv> tvList = new ArrayList<Tv>();
   tvList.add(new Tv());
 //  tvList.add(new Audio());  Tv타입 지정했으므로 컴파일 에러 확인 가능 -> 장점 : 타입 안정성 제공 
 
 	TV t = tvList.get(0);   //형변환 불필요 -> 장점 : 코드 간결 
 
 
 
   3. 제네릭 선언시 사용하는 T,V,E 등의 알파벳은 어떤 알파벳이든 상관없다 .
   T : Type  & E : Element  &  K : Key  &  V : Value
   하지만 이러한 뜻을 가진 알파벳을 많이 사용하는 편이다. 
   
   
   
   4. 제네릭의 다형성 
   * 참조 변수와 생성자의 대입된 타입은 일치해야 한다. 
   Food<String> food = new Rice<String>(); 제네릭타입은 일치하기, 클래스는 상속관계시 불일치 가능 
   
   
   5. 제네릭의 형변환 
    1) Generic 타입과 원시 타입 간의 형변환은 바람직 하지 않다.(경고 발생)
       //jdk1.5이후 제네릭 도입했고, 하위호환성을 유지하기 위해서 에러가 나지는 않는다
       // 하지만 경고이므로 되도록 제네릭사용 가능 클래스는 제네릭을 사용하자
       
    2) 서로 다른 타입이 대입된 제네릭 타입끼리의 변환은 에러 발생  -> 단순하게 제네릭타입자체가 불일치하기 때문에 안됨  
    
    3) 와일드 카드가 사용된 지네릭 타입으로는 형변환이 가능
   
   
   
   6. 제네릭 제약 
     1) static 멤버에는 타입 변수가 사용이 불가하다.
     -> 클래스 객체가 생성하기 전에 <T>선언한 멤버가 먼저 메모리에 올라가고, 이때 <T>가 대입되기 전이니 불가능함 
     2) 배열/객체 생성시 타입 변수는 사용이 불가능하다.== new T에러 
     ==>    생성시엔 타입명확해야 객체 생성 가능함 
   
   
   7. 와일드 카드 
    < ? extends T > : 와일드카드의 상한 제한, T와 그 자손들 가능
	< ? super T > : 와일드카드의 하한 제한, T와 그 조상들 가능
	< ? > : 제한 없음, 모든 타입이 가능하다.
   
   
   8. 제네릭 메서드 
    1) 제네릭 타입이 선언된 메서드 
    2) 클래스의 타입 매개변수<T>와 메서드의 타입 매개변수 <T>(지역변수)는 별개이다. 
    3) 메서드를 호출할 때마다 타입을 대입해야한다. 메서드 호출시 타입은 정해져 있으므로 사용 가능 
    
   
